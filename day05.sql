-- 사원테이블에서 직종, 평균급여를 출력하되 평균 급여가 BRUCE보다 큰 경우만 조회
SELECT JOB_ID, AVG(SALARY) FROM EMPLOYEES 
GROUP BY JOB_ID 
HAVING AVG(SALARY) > (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'Bruce');

-- 사원테이블에서 성에 'Bat'을 포함하는 사원과 같은 부서에서 근무하는 사원들의 부서번호, 이름을 출력
SELECT DEPARTMENT_ID, FIRST_NAME 
FROM EMPLOYEES 
WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE LAST_NAME LIKE '%Bat%');

-- 사원테이블에서 100번 부서의 최소 급여보다 많이 받는 다른 부서의 부서번호, 최소급여를 조회하세요
SELECT DEPARTMENT_ID, MIN(SALARY) FROM EMPLOYEES GROUP BY DEPARTMENT_ID 
HAVING MIN(SALARY) > (SELECT MIN(SALARY) FROM EMPLOYEES WHERE DEPARTMENT_ID = 100);

SELECT * FROM PLAYER;

-- PLAYER테이블에서 TEAM_ID가 'K01'인 선수 중 POSITION이 'GK'인 선수를 조회
SELECT * FROM (SELECT * FROM PLAYER WHERE TEAM_ID = 'K01') WHERE "POSITION" = 'GK';

-- PLAYER테이블에서 전체 평균키와 포지션별 평균키 구하기
SELECT "POSITION", AVG(HEIGHT), (SELECT AVG(HEIGHT) FROM PLAYER) 
FROM PLAYER 
WHERE "POSITION" IS NOT NULL 
GROUP BY "POSITION";

-- AUTO COMMIT
-- 내가 실행하는 쿼리문이 테이블에 바로 반영
-- COMMIT이 되면 되돌아가는 것이 불가능하다.
-- 원래는 작성한 쿼리문이 임시저장소에 보관되고 여기서 실행을 해야 테이블에 완전히 저장되는 구조이다.

-- PLAYER테이블에서 NICKNAME이 NULL인 선수들은
-- 정태민 선수의 닉네임으로 변경하기

UPDATE PLAYER SET NICKNAME = (SELECT NICKNAME FROM PLAYER WHERE PLAYER_NAME = '정태민') WHERE NICKNAME IS NULL;
SELECT PLAYER_NAME, NICKNAME FROM PLAYER;

-- 임시로 저장된 상태임
-- 결과를 되돌릴 때는 롤백
-- 결과를 적용할 때는 커밋을 누른다.

-- 사원테이블에서 평균 급여보다 낮은 사원들의 급여를 10% 인상
UPDATE EMPLOYEES SET SALARY = SALARY * 1.1 WHERE SALARY < (SELECT AVG(SALARY) FROM EMPLOYEES);
SELECT AVG(SALARY) FROM EMPLOYEES;

SELECT AVG(HEIGHT) FROM PLAYER;
-- PLAYER테이블에서 평균키보다 큰 선수들을 삭제
DELETE FROM PLAYER WHERE HEIGHT > (SELECT AVG(HEIGHT) FROM PLAYER);
SELECT * FROM PLAYER;

-- FROM절에서 쓸 때 : IN LINE VIEW
-- SELECT절에서 쓸 때 : SCALAR
-- WHERE절에서 쓸 때 : SUB QUERY

-- 사원테이블에서 성과 이름 연결하기
SELECT FIRST_NAME||' '||LAST_NAME FROM EMPLOYEES;

-- XX의 급여는 XX이다.
SELECT FIRST_NAME||' '||LAST_NAME||'의 급여는 '||SALARY||'이다.' FROM EMPLOYEES;

SELECT
	COUNT(SALARY) AS 개수,
	MAX(SALARY) AS 최대값,
	MIN(SALARY) AS 최소값,
	SUM(SALARY) AS 총합,
	AVG(SALARY) AS 평균
FROM EMPLOYEES;

-- 사원테이블에서 EMPLOYEE_ID를 사번, FIRST_NAME을 이름, SALARY를 급여로 별칭을 주고 전체 내용 조회하기
SELECT EMPLOYEE_ID AS 사번, FIRST_NAME AS 이름, SALARY AS 급여 FROM EMPLOYEES;

-- 두 개 이상의 테이블에서 컬럼을 조회할 때 어떤 테이블에서 온 컬럼인지 확실하게 적어줘야 한다.
SELECT e.DEPARTMENT_ID, d.DEPARTMENT_ID
FROM EMPLOYEES e, DEPARTMENTS d;

-- 사원테이블에는 부서명이 없다.
-- 부서테이블에는 DEPARTMENT_ID컬럼을 PK로 가지고 있다.
-- 사원테이블에는 DEPARTMENT_ID컬럼을 외래키로 가지고 있다.

SELECT E.FIRST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

-- 부서테이블, 지역테이블로부터 부서명과 도시명을 조회하세요
SELECT d.DEPARTMENT_NAME, l.CITY
FROM DEPARTMENTS d JOIN LOCATIONS l
ON D.LOCATION_ID = L.LOCATION_ID;



-- 지역테이블과, 나라테이블(countries)를 조회하여 도시명과 국가명(country_name)을 조회하세요
SELECT l.CITY, c.COUNTRY_NAME FROM LOCATIONS l 
JOIN COUNTRIES c 
ON L.COUNTRY_ID = C.COUNTRY_ID;

-- 이름, 성, 직종, 직업명을 조회해주세요
-- EMPLOYEES, JOBS테이블을 이용한다.
SELECT e.FIRST_NAME, e.LAST_NAME, e.JOB_ID, j.JOB_TITLE
FROM EMPLOYEES e JOIN JOBS j
ON e.JOB_ID = j.JOB_ID;

-- 테이블 3개 조인하기
-- 지역테이블로부터 이름, 이메일, 부서번호, 부서명, 지역번호, 도시명
SELECT e.FIRST_NAME, e.EMAIL, e.DEPARTMENT_ID, d.DEPARTMENT_NAME, l.LOCATION_ID, l.CITY 
FROM EMPLOYEES e JOIN DEPARTMENTS d
ON e.DEPARTMENT_ID = d.DEPARTMENT_ID
JOIN LOCATIONS l 
ON d.LOCATION_ID = l.LOCATION_ID
AND l.CITY = 'Seattle';

SELECT * FROM EMP;
SELECT E2.ENAME, E2.MGR 직원, E1.ENAME 상사, E1.EMPNO 
FROM EMP E1 
JOIN EMP E2 
ON E2.MGR = E1.EMPNO;

CREATE TABLE 테이블A(
	A_id NUMBER,
	A_NAME VARCHAR2(10)
);


CREATE TABLE 테이블B(
	B_id NUMBER,
	B_NAME VARCHAR2(10)
);

INSERT ALL
	INTO 테이블A values(1,'Jhon')
	INTO 테이블A values(2,'Jane')
	INTO 테이블A values(3,'Bob')
	INTO 테이블B values(101,'Apple')
	INTO 테이블B values(102,'Banana')
SELECT * FROM dual;

SELECT * FROM 테이블A;
SELECT * FROM 테이블B;

SELECT * FROM 테이블A CROSS JOIN 테이블B;

-- 사원테이블과 부서테이블의 LEFT OUTER JOIN을 이용하여 사원이 어느 부서에 있는지 조회하기
SELECT FIRST_NAME, DEPARTMENT_NAME 
FROM EMPLOYEES e 
LEFT OUTER JOIN DEPARTMENTS d 
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

-- 사원테이블과 부서테이블의 RIGHT OUTER JOIN을 이용하여 사원이 어느 부서에 있는지 조회하기
SELECT FIRST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES E
RIGHT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

SELECT FIRST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES E
FULL OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

-- TEAM테이블과 STADIUM테이블을 통해 홈팀이 있는 구장만 
-- 팀 이름과 구장이름으로 조회
SELECT TEAM_NAME, STADIUM_NAME
FROM TEAM t
LEFT OUTER JOIN STADIUM s
ON T.STADIUM_ID = S.STADIUM_ID;
-- RIGHT OUTER JOIN하면 홈팀이 없는 구장까지 다 나오게 된다.

-- 사원테이블에서 누가 얼마받는지에 대한 조회
CREATE OR REPLACE VIEW MY_EMPL AS(
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, (SALARY * COMMISSION_PCT) COMM
FROM EMPLOYEES  
);
-- OR REPLACE를 통해 내부의 쿼리문을 언제든 수정할 수 있다.
SELECT * FROM MY_EMPL;

SELECT * FROM PLAYER;
-- VIEW 이름: PLAYER_AGE
-- 선수의 이름과 나이를 조회하는 쿼리를 넣기
CREATE OR REPLACE VIEW PLAYER_AGE AS(
SELECT PLAYER_NAME, ROUND((SYSDATE - BIRTH_DATE)/365) AGE 
FROM PLAYER
);

SELECT * FROM PLAYER_AGE;

-- 나이가 30살 이상인 선수들만 검색하시오
SELECT * FROM PLAYER_AGE WHERE AGE >= 30;

-- VIEW 이름 : DATA_PLUS
-- 급여를 많이 받는 순으로 순위와 이름, 급여를 조회하는 쿼리 넣기
CREATE OR REPLACE VIEW DATA_PLUS AS(
	SELECT DENSE_RANK() OVER(ORDER BY SALARY DESC) "RANK", FIRST_NAME, SALARY
	FROM EMPLOYEES e
	GROUP BY FIRST_NAME, SALARY
);

SELECT * FROM DATA_PLUS;

--PLAYER테이블 뒤에 TEAM_NAME 컬럼을 추가한 VIEW 만들기
--JOIN을 사용하면 됨
-- 뷰이름 : PLAYER_TEAM_NAME
CREATE OR REPLACE VIEW PLAYER_TEAM_NAME AS(
	SELECT p.*, TEAM_NAME FROM PLAYER p
	JOIN TEAM t
	ON P.TEAM_ID = T.TEAM_ID
);

SELECT * FROM PLAYER_TEAM_NAME;

-- HOMETEAM_ID, STADIUM_NAME, TEAM_NAME을 조회
-- 홈팀이 없는 경기장도 검색하기
-- 뷰이름 : STADIUM_INFO
CREATE OR REPLACE VIEW STADIUM_INFO AS(
SELECT HOMETEAM_ID, STADIUM_NAME, TEAM_NAME FROM STADIUM s
LEFT OUTER JOIN TEAM t
ON T.TEAM_ID = S.HOMETEAM_ID
);

SELECT * FROM STADIUM_INFO;

-- 홈팀이 없는 경기장을 검색하세요
SELECT * FROM STADIUM_INFO WHERE HOMETEAM_ID IS NULL;

-- EMPLOYEES테이블에서 JOB_ID가 'IT_PROG'인 사람의 이름을 
-- 자신의 이름으로 바꾸기
SELECT EMPLOYEE_ID, FIRST_NAME, JOB_ID FROM EMPLOYEES e;
UPDATE EMPLOYEES SET FIRST_NAME = '조한얼' WHERE JOB_ID = 'IT_PROG';
--실행하면 이름이 바뀐채로 조회, 롤백 누르고 다시 실행하면 원래대로 복귀

-- 데이터베이스에 영향을 주는 INSERT, UPDATE, DELETE문에서
-- 많이 사용된다.












